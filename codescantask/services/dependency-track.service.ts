// SPDX-License-Identifier: MIT
/*
   Copyright (c) 2025, SCANOSS

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   THE SOFTWARE.
 */

import * as tl from 'azure-pipelines-task-lib';
import * as inputs from '../app.input';
import { setDependencyTrackProjectId, setDependencyTrackUploadToken } from '../app.input';
import { CYCLONEDX_FILE_NAME } from '../app.output';
import { DependencyTrackUploadResult } from './dependency-track-status.service';
import fs from 'fs';
import path from 'path';

/**
 * Configuration options for Dependency Track integration.
 * Supports two modes of project identification:
 * 1. By existing project ID (UUID)
 * 2. By project name + version (will create if doesn't exist)
 */
export interface DependencyTrackOptions {
    /** Whether Dependency Track upload is enabled */
    enabled: boolean;
    /** Base URL of the Dependency Track server */
    url: string | undefined;
    /** API key for server authentication */
    apiKey: string | undefined;
    /** UUID of existing project (optional if name+version provided) */
    projectId: string | undefined;
    /** Project name for creation/lookup (optional if ID provided) */
    projectName: string | undefined;
    /** Project version (required with name, optional with ID) */
    projectVersion: string | undefined;
}

/**
 * Service for integrating with Dependency Track for vulnerability and policy management.
 *
 * This service handles the upload of Software Bill of Materials (SBOM) in CycloneDX format
 * to a Dependency Track server instance. It performs the following operations:
 *
 * 1. Validates configuration parameters (URL, API key, project identification)
 * 2. Reads and parses the CycloneDX SBOM file generated by SCANOSS
 * 3. Uploads the SBOM to Dependency Track via the scanoss-py Docker container
 * 4. Parses the response to extract project UUID and upload token
 * 5. Provides detailed error messages for common failure scenarios
 *
 * The service supports both existing project uploads (via project ID) and automatic
 * project creation (via project name + version).
 *
 * @example
 * ```typescript
 * const service = new DependencyTrackService();
 * const result = await service.uploadToDependencyTrack();
 * if (result.success) {
 *   console.log(`Uploaded ${result.componentsCount} components`);
 * }
 * ```
 */
export class DependencyTrackService {
    /** Minimum acceptable length for API key validation */
    private readonly MINIMUM_APIKEY_LENGTH = 10;
    /** Configuration options for this service instance */
    private options: DependencyTrackOptions;

    constructor(options?: DependencyTrackOptions) {
        this.options = options || {
            enabled: inputs.DEPENDENCY_TRACK_ENABLED,
            url: inputs.DEPENDENCY_TRACK_URL,
            apiKey: inputs.DEPENDENCY_TRACK_API_KEY,
            projectId: inputs.DEPENDENCY_TRACK_PROJECT_ID,
            projectName: inputs.DEPENDENCY_TRACK_PROJECT_NAME,
            projectVersion: inputs.DEPENDENCY_TRACK_PROJECT_VERSION
        };
    }

    /**
     * Validates that all required Dependency Track parameters are provided
     * @returns true if configuration is valid, false if parameters are missing
     */
    private validateConfiguration(): boolean {
        const missingParams: string[] = [];
        const invalidParams: string[] = [];
        // Check required parameters
        if (!this.options.url) {
            missingParams.push('deptrack.url');
        } else {
            // Validate URL format
            try {
                const url = new URL(this.options.url);
                if (!['http:', 'https:'].includes(url.protocol)) {
                    invalidParams.push('deptrack.url (must use http:// or https://)');
                }
            } catch (e: any) {
                invalidParams.push(`deptrack.url (invalid URL format): ${e.message}`);
            }
        }
        if (!this.options.apiKey) {
            missingParams.push('deptrack.apikey');
        } else if (this.options.apiKey.length < this.MINIMUM_APIKEY_LENGTH) {
            // Basic API key validation - Dependency Track API keys are typically longer
            invalidParams.push('deptrack.apikey (appears to be too short)');
        }
        if (missingParams.length > 0) {
            tl.warning(
                `Dependency Track upload skipped: Required parameters are missing.\n` +
                `Missing: ${missingParams.join(', ')}\n` +
                `Please set these parameters in your workflow configuration.`
            );
            return false;
        }
        if (invalidParams.length > 0) {
            tl.warning(
                `Dependency Track upload skipped: Invalid parameter values.\n` +
                `Invalid: ${invalidParams.join(', ')}\n` +
                `Please check your parameter values and try again.`
            );
            return false;
        }
        // Check project identification - must have either projectId OR (projectName + projectVersion)
        if (!this.options.projectId) {
            const missingProjectParams: string[] = [];
            if (!this.options.projectName) missingProjectParams.push('deptrack.projectname');
            if (!this.options.projectVersion) missingProjectParams.push('deptrack.projectversion');
            if (missingProjectParams.length > 0) {
                tl.warning(
                    `Dependency Track upload skipped: Project identification is incomplete.\n` +
                    `You must provide EITHER:\n` +
                    `  • deptrack.projectid (for existing projects), OR\n` +
                    `  • Both deptrack.projectname AND deptrack.projectversion (to create/find projects)\n\n` +
                    `Missing: ${missingProjectParams.join(', ')}`
                );
                return false;
            }
        }
        return true;
    }

    /**
     * Converts SCANOSS results to CycloneDX format and uploads to Dependency Track
     * @returns DependencyTrackUploadResult with detailed upload information
     */
    async uploadToDependencyTrack(): Promise<DependencyTrackUploadResult> {
        const startTime = Date.now();
        try {
            if (!this.options.enabled) {
                tl.debug('Dependency Track upload is disabled');
                return {
                    success: false,
                    enabled: false
                };
            }
            if (!this.validateConfiguration()) {
                return {
                    success: false,
                    enabled: true,
                    error: 'Configuration validation failed'
                };
            }
            // Get file information before upload if we can
            let fileSize: number | undefined;
            let componentsCount: number | undefined;
            try {
                const cycloneDxPath = path.join(inputs.REPO_DIR, CYCLONEDX_FILE_NAME);
                const stats = await fs.promises.stat(cycloneDxPath);
                fileSize = stats.size;
                // Try to get component count from CycloneDX file
                const cycloneDxContent = await fs.promises.readFile(cycloneDxPath, 'utf-8');
                const cycloneDxData = JSON.parse(cycloneDxContent);
                componentsCount = cycloneDxData.components?.length || 0;
            } catch (fileError: any) {
                tl.warning(`Could not read SBOM file details: ${fileError.message}`);
            }
            console.log('Starting Dependency Track upload process...');
            const uploadError = await this.uploadCycloneDXToDependencyTrack();
            const uploadTime = (Date.now() - startTime) / 1000;
            if (uploadError) {
                tl.error(uploadError.message);
                return {
                    success: false,
                    enabled: true,
                    error: uploadError.message,
                    projectName: this.options.projectName,
                    projectVersion: this.options.projectVersion,
                    fileSize,
                    componentsCount,
                    uploadTime
                };
            }
            return {
                success: true,
                enabled: true,
                projectId: inputs.DEPENDENCY_TRACK_PROJECT_ID,
                uploadToken: inputs.DEPENDENCY_TRACK_UPLOAD_TOKEN,
                projectName: this.options.projectName,
                projectVersion: this.options.projectVersion,
                fileSize,
                componentsCount,
                uploadTime
            };
        } catch (e: any) {
            const uploadTime = (Date.now() - startTime) / 1000;
            tl.error(e.message);
            return {
                success: false,
                enabled: true,
                error: e.message,
                uploadTime
            };
        }
    }

    /**
     * Parses error messages from stderr and returns user-friendly error descriptions.
     *
     * Analyzes the error text to identify common failure scenarios and provides
     * specific troubleshooting guidance for each case. Supports detection of:
     * - Connection errors (server unreachable)
     * - Authentication errors (invalid API key)
     * - Not found errors (invalid endpoint or project)
     * - Timeout errors (slow server response)
     * - SSL/TLS errors (certificate validation issues)
     * - Permission errors (insufficient access rights)
     *
     * @param stderr - The error output from the Docker/scanoss-py execution
     * @returns A formatted, user-friendly error message with troubleshooting steps
     */
    private parseUploadError(stderr: string): string {
        const lowerStderr = stderr.toLowerCase();
        // Determine error type based on stderr content
        const getErrorType = (): string => {
            if (lowerStderr.includes('connection refused') || lowerStderr.includes('no route to host')) {
                return 'CONNECTION_ERROR';
            }
            if (
                lowerStderr.includes('401') ||
                lowerStderr.includes('unauthorized') ||
                lowerStderr.includes('invalid api key')
            ) {
                return 'AUTH_ERROR';
            }
            if (lowerStderr.includes('project') && lowerStderr.includes('not found')) {
                return 'PROJECT_NOT_FOUND';
            }
            if (lowerStderr.includes('404') || lowerStderr.includes('not found')) {
                return 'NOT_FOUND_ERROR';
            }
            if (lowerStderr.includes('timeout') || lowerStderr.includes('timed out')) {
                return 'TIMEOUT_ERROR';
            }
            if (lowerStderr.includes('ssl') || lowerStderr.includes('certificate') || lowerStderr.includes('tls')) {
                return 'SSL_ERROR';
            }
            if (lowerStderr.includes('forbidden') || lowerStderr.includes('403')) {
                return 'FORBIDDEN_ERROR';
            }
            return 'GENERIC_ERROR';
        };
        switch (getErrorType()) {
            case 'CONNECTION_ERROR':
                return (
                    `Cannot connect to Dependency Track server.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: Server is not reachable\n` +
                    `• Solutions: Verify the URL, check network connectivity, ensure server is running`
                );
            case 'AUTH_ERROR':
                return (
                    `Authentication failed with Dependency Track server.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: Invalid or missing API key\n` +
                    `• Solutions: Verify your API key, check user permissions in Dependency Track`
                );
            case 'NOT_FOUND_ERROR':
                return (
                    `Dependency Track server endpoint not found.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: Server endpoint does not exist\n` +
                    `• Solutions: Verify the URL is correct, check if Dependency Track is properly deployed`
                );
            case 'TIMEOUT_ERROR':
                return (
                    `Connection to Dependency Track server timed out.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: Server is too slow to respond\n` +
                    `• Solutions: Check network connectivity, verify server performance, try again later`
                );
            case 'SSL_ERROR':
                return (
                    `SSL/TLS connection error with Dependency Track server.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: SSL certificate validation failed\n` +
                    `• Solutions: Check SSL certificate validity, ensure proper HTTPS configuration`
                );
            case 'PROJECT_NOT_FOUND':
                return (
                    `Project not found in Dependency Track.\n` +
                    `• Project ID: ${this.options.projectId || 'Not specified'}\n` +
                    `• Project Name: ${this.options.projectName || 'Not specified'}\n` +
                    `• Solutions: Verify project exists, check project ID/name, create project first`
                );
            case 'FORBIDDEN_ERROR':
                return (
                    `Access forbidden to Dependency Track resource.\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Issue: Insufficient permissions\n` +
                    `• Solutions: Check API key permissions, verify user role in Dependency Track`
                );
            default:
                return (
                    `Dependency Track upload failed with error:\n${stderr}\n\n` +
                    `Troubleshooting:\n` +
                    `• Verify URL: ${this.options.url}\n` +
                    `• Check that the server is running and accessible\n` +
                    `• Ensure API key is valid and has proper permissions\n` +
                    `• Verify project exists or can be created automatically`
                );
        }
    }

    /**
     * Constructs Docker command arguments for SBOM upload to Dependency Track.
     *
     * Builds the complete command line arguments array for executing the scanoss-py
     * Docker container's `export dependency-track` command. Includes:
     * - Volume mount for repository access
     * - Runtime container specification
     * - Input file path (CycloneDX SBOM)
     * - Authentication parameters (API key, URL)
     * - Project identification (ID or name+version)
     *
     * @returns Array of command line arguments for Docker execution
     */
    private buildDependencyTrackUploadParameters(): string[] {
        return [
            'run',
            '-v',
            `${inputs.REPO_DIR}:/scanoss`,
            inputs.RUNTIME_CONTAINER,
            'export',
            'dependency-track',
            '--input',
            `./${CYCLONEDX_FILE_NAME}`,
            ...(this.options.apiKey ? ['-k', this.options.apiKey] : []),
            ...(this.options.url ? ['--url', this.options.url] : []),
            ...(this.options.projectId ? ['-pid', this.options.projectId] : []),
            ...(this.options.projectName ? ['-pn', this.options.projectName] : []),
            ...(this.options.projectVersion ? ['-pv', this.options.projectVersion] : [])
        ];
    }

    /**
     * Executes the actual SBOM upload to Dependency Track via Docker.
     *
     * This method:
     * 1. Builds the Docker command with all necessary parameters
     * 2. Executes the command synchronously to capture output
     * 3. Checks the exit code (0 = success, non-zero = failure)
     * 4. Parses the JSON response to extract upload token and project UUID
     * 5. Stores the token and UUID for use in policy checks
     * 6. Handles and categorizes any errors that occur
     *
     * The scanoss-py container returns a JSON response with:
     * - `token`: Upload token for subsequent policy violation queries
     * - `project_uuid`: The Dependency Track project UUID
     *
     * @returns Error object if upload failed, undefined if successful
     */
    private async uploadCycloneDXToDependencyTrack(): Promise<Error | undefined> {
        // Use execSync to capture stdout/stderr
        const results = tl.execSync(
            inputs.EXECUTABLE,
            this.buildDependencyTrackUploadParameters()
        );
        if (results.code !== 0) {
            let errorMessage;
            if (results.stderr) {
                errorMessage = this.parseUploadError(results.stderr);
            } else {
                errorMessage =
                    `Dependency Track upload failed (exit code ${results.code}).\n` +
                    `• URL: ${this.options.url}\n` +
                    `• Check server connectivity and configuration`;
            }
            return new Error(errorMessage);
        }
        // Upload succeeded - show success message
        console.log('CycloneDX successfully uploaded to Dependency Track');
        if (results.stderr) {
            // Log stderr for debugging but don't treat as error if exitCode is 0
            tl.debug(`Dependency Track upload stderr: ${results.stderr}`);
            // Filter out harmless informational messages
            const trimmedStderr = results.stderr.trim();
            const isHarmlessInfo =
                trimmedStderr.startsWith('Reading SBOM file:') ||
                trimmedStderr.includes('Reading SBOM file:') ||
                trimmedStderr.match(/^Reading .+ file:/);
            if (!isHarmlessInfo) {
                tl.warning('Dependency Track upload completed with warnings. Check debug logs for details.');
            }
        }
        try {
            const response = JSON.parse(results.stdout);
            setDependencyTrackUploadToken(response.token);
            setDependencyTrackProjectId(response.project_uuid);
        } catch (parseError: any) {
            tl.warning(`Could not parse Dependency Track response: ${parseError.message}`);
            tl.debug(`Raw stdout: ${results.stdout}`);
        }
    }
}

export const dependencyTrackService = new DependencyTrackService();
